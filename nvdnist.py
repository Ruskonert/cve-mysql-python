#!/usr/bin/python3
# -*- coding: utf-8 -*-
import concurrent.futures
import json
import os
import re
import sys
import traceback

import util
from cve import CVEDatabase
from cvemysql import initialize
from database import TableColumn

NVD_NIST_JSON_URL = 'https://nvd.nist.gov/feeds/json/cve/1.0/'
NVD_NIST_XML_URL = 'https://nvd.nist.gov/feeds/xml/cve/2.0/'


class SQLWorker:
    def __init__(self, function):
        self._executor = None
        self._submit = []
        self._function = function

    def initialize(self, worker):
        executor = concurrent.futures.ProcessPoolExecutor(max_workers=worker)
        if executor is not None:
            self._executor = executor
        return self

    def as_complete(self):
        return concurrent.futures.as_completed(self._submit)

    def terminate(self):
        self._executor.shutdown(False)

    def reserve(self, *obj):
        # for test value
        o = obj[0]
        o1 = obj[1]
        o2 = obj[2]
        o3 = obj[3]
        o4 = obj[4]
        o5 = obj[5]
        o6 = obj[6]
        self._submit.append(self._executor.submit(self._function, o, o1, o2, o3, o4, o5, o6))


def workstation(sql_user, sql_password, sql_host, sql_port, sql_database, tablename, jsonElement):
    try:
        # PyMySQL has multiprocess-safety while a per time, So It needs to new connect.
        # The variable name is very important.
        # Because the python interpreter checks name and matchs each of the table columns.
        new_db = initialize(sql_user, sql_password, sql_host, sql_port)
        base = Nvdnist(new_db)
        base.use_database(sql_database)

        result = 0

        ID = str(jsonElement['cve_id'])
        p = re.compile(r'CVE-(\d{4})-.+$')
        year = str(p.match(ID).group(1))

        ASSIGNER = str(jsonElement['assigner'])
        data_type = str(jsonElement['data_type'])
        data_format = str(jsonElement['data_format'])
        data_version = str(jsonElement['data_version'])
        cve_data_version = str(jsonElement['CVE_data_version'])
        reference_url = ""
        description_value = ""
        problemtype = ""

        for d in base.find_key(jsonElement, r"reference_.+$"):
            reference_url += jsonElement[d] + " | "
        reference_url = reference_url[:-3]

        for d in base.find_key(jsonElement, r"desc_(.+)"):
            description_value += jsonElement[d] + " | "
        description_value = description_value[:-3]

        for d in base.find_key(jsonElement, r"cwe_\d"):
            problemtype += jsonElement[d] + " | "
        problemtype = problemtype[:-3]

        cpe_list = []

        r = base.find_key(jsonElement, r"cpe_[0-9]+_vulnderable")
        if len(r) != 0:
            for index, c in enumerate(r):
                cpe_list.append(str(jsonElement[c]) + "||")

            for index, c in enumerate(base.find_key(jsonElement, r"cpe_[0-9]+_cpe22uri")):
                cpe_list[index] += (str(jsonElement[c])) + "||"

            for index, c in enumerate(base.find_key(jsonElement, r"cpe_[0-9]+_cpe23uri")):
                cpe_list[index] += (str(jsonElement[c])) + "||"

            for index, c in enumerate(base.find_key(jsonElement, r"cpe_[0-9]+_number")):
                cpe_list[index] += (str(jsonElement[c]))

        data = base.find_key(jsonElement, r"affect_[0-9]+")
        safe_insert = False
        sizeOf = len(data) * len(cpe_list)
        if sizeOf > 0xFFFF:
            safe_insert = True
            print("\n[ Warning: {id} has {s} elements, It takes a lot of time, Safety-mode enabled ] \n".format(id=ID,
                                                                                                                s=sizeOf))

        # for version 2
        baseMetricV2_version = str(jsonElement.get('baseMetricV2.version', ''))
        baseMetricV2_vectorString = str(jsonElement.get('baseMetricV2.vectorString', ''))
        baseMetricV2_accessVector = str(jsonElement.get('baseMetricV2.accessVector', ''))
        baseMetricV2_accessComplexity = str(jsonElement.get('baseMetricV2.accessComplexity', ''))
        baseMetricV2_authentication = str(jsonElement.get('baseMetricV2.authentication', ''))
        baseMetricV2_confidentialityImpact = str(jsonElement.get('baseMetricV2.confidentialityImpact', ''))
        baseMetricV2_integrityImpact = str(jsonElement.get('baseMetricV2.integrityImpact', ''))
        baseMetricV2_availabilityImpact = str(jsonElement.get('baseMetricV2.availabilityImpact', ''))
        baseMetricV2_baseScore = str(jsonElement.get('baseMetricV2.baseScore', ''))
        baseMetricV2_severity = str(jsonElement.get('baseMetricV2.severity', ''))
        baseMetricV2_exploitabilityScore = str(jsonElement.get('baseMetricV2.exploitabilityScore', ''))
        baseMetricV2_impactScore = str(jsonElement.get('baseMetricV2.impactScore', ''))
        baseMetricV2_obtainAllPrivilege = str(jsonElement.get('baseMetricV2.obtainAllPrivilege', ''))
        baseMetricV2_obtainUserPrivilege = str(jsonElement.get('baseMetricV2.obtainUserPrivilege', ''))
        baseMetricV2_obtainOtherPrivilege = str(jsonElement.get('baseMetricV2.obtainOtherPrivilege', ''))
        baseMetricV2_userInteractionRequired = str(jsonElement.get('baseMetricV2.userInteractionRequired', ''))

        # for version 3
        baseMetricV3_version = str(jsonElement.get('baseMetricV3.version', ''))
        baseMetricV3_vectorString = str(jsonElement.get('baseMetricV3.vectorString', ''))
        baseMetricV3_attackVector = str(jsonElement.get('baseMetricV3.attackVector', ''))
        baseMetricV3_attackComplexity = str(jsonElement.get('baseMetricV3.attackComplexity', ''))
        baseMetricV3_privilegesRequired = str(jsonElement.get('baseMetricV3.privilegesRequired', ''))
        baseMetricV3_userInteraction = str(jsonElement.get('baseMetricV3.userInteraction', ''))

        baseMetricV3_scope = str(jsonElement.get('baseMetricV3.scope', ''))
        baseMetricV3_confidentialityImpact = str(jsonElement.get('baseMetricV3.confidentialityImpact', ''))
        baseMetricV3_integrityImpact = str(jsonElement.get('baseMetricV3.integrityImpact', ''))
        baseMetricV3_availabilityImpact = str(jsonElement.get('baseMetricV3.availabilityImpact', ''))
        baseMetricV3_baseScore = str(jsonElement.get('baseMetricV3.baseScore', ''))
        baseMetricV3_baseSeverity = str(jsonElement.get('baseMetricV3.baseSeverity', ''))
        baseMetricV3_exploitabilityScore = str(jsonElement.get('baseMetricV3.exploitabilityScore', ''))
        baseMetricV3_impactScore = str(jsonElement.get('baseMetricV3.impactScore', ''))

        publishedDate = str(jsonElement.get('publishedDate', ''))
        lastModifiedDate = str(jsonElement.get('lastModifiedDate', ''))

        # Unused variable for column fields
        c = None
        d = None

        sql_data = {'sql_user': False, 'sql_database': False, 'sql_port': False, 'sql_host': False,
                    'sql_password': False, 'tablename': False}
        filter_vars = lambda l: isinstance(l[1], str) and sql_data.get(l[0], True) and l[1] is not None

        if safe_insert:
            subWorker = SQLWorker(_cpeList).initialize(2)

            # Check the cpe elements has at least 1
            while len(data) != 0:
                defined = None
                r = jsonElement[data.pop()].split(' || ')
                defined = dict((i, j) for i, j in filter(filter_vars, list(dict(vars()).items())))
                subWorker._submit.append(
                    subWorker._executor.submit(subWorker._function, sql_user, sql_password, sql_host, sql_port,
                                               sql_database, tablename, r, cpe_list, defined))

            for ps in subWorker.as_complete():
                result = result + ps.result()

            subWorker.terminate()

        else:
            while len(data) != 0:
                r = jsonElement[data.pop()].split(' || ')
                cpe_list_clone = list(cpe_list)
                cpe_list_clone.reverse()

                # It will use the value of table columns.
                affects_vendor_name = r[0]
                affects_product_name = r[1]
                affects_version_value = r[2]

                while len(cpe_list_clone) != 0:
                    defined = None
                    cp = cpe_list_clone.pop()
                    r = cp.split('||')

                    # It will use the value of table columns.
                    nodes_cpe_vulnerable = r[0]
                    nodes_cpe_cpe22uri = r[1]
                    nodes_cpe_cpe23uri = r[2]
                    nodes_cpe = r[3]

                    # unused variable at column fields
                    r = None
                    cp = None

                    # Get deined variables
                    defined = dict((i, j) for i, j in filter(filter_vars, list(dict(vars()).items())))

                    if execute(base, tablename, defined):
                        result = result + 1
                    else:
                        print('err\n')
        base.disconnect()
        return result
    except (KeyboardInterrupt, SystemExit):
        print("Interrupt")
        sys.exit(0)


def _cpeList(sql_user, sql_password, sql_host, sql_port, sql_database, tablename, r, cpe_list, variable):
    base = initialize(sql_user, sql_password, sql_host, sql_port)
    base.use_database(sql_database)
    result = 0
    cpe_list_clone = list(cpe_list)
    cpe_list_clone.reverse()

    affects_vendor_name = r[0]
    affects_product_name = r[1]
    affects_version_value = r[2]

    nodes_cpe_vulnerable = None
    nodes_cpe_cpe22uri = None
    nodes_cpe_cpe23uri = None
    nodes_cpe = None

    # unused variable at column fields
    sql_user = None
    sql_database = None
    sql_port = None
    sql_host = None
    sql_password = None

    sql_data = {'sql_user': False, 'sql_database': False, 'sql_port': False, 'sql_host': False, 'sql_password': False,
                'tablename': False}
    filter_vars = lambda l: isinstance(l[1], str) and sql_data.get(l[0], True) and l[1] is not None

    while len(cpe_list_clone) != 0:
        cp = cpe_list_clone.pop().split('||')
        nodes_cpe_vulnerable = cp[0]
        nodes_cpe_cpe22uri = cp[1]
        nodes_cpe_cpe23uri = cp[2]
        nodes_cpe = cp[3]

        cp = None
        current_variable = dict(vars())

        defined = dict((i, j) for i, j in filter(filter_vars, list(current_variable.items())))
        defined.update(variable)

        if execute(base, tablename, defined):
            result = result + 1
        else:
            print('sub-process err\n')
    base.disconnect()
    return result


def execute(base, tablename, variable):
    query_header = "("
    query_format = "("
    query_argument = []

    # automatic insert value
    for variable_name in variable.keys():
        query_header += variable_name + ','
        query_format += "%s,"
        query_argument.append(variable[variable_name])

    query_header = query_header[:-1]
    query_header += ")"

    query_format = query_format[:-1]
    query_format += ")"
    return base.send_query(
        "INSERT INTO {table_name} {header} VALUES {format}".format(table_name=tablename, header=query_header,
                                                                   format=query_format), tuple(query_argument))


execption_list = {}


def problemtype_data(cve_problemtype):
    problemtype_list = []
    for data in cve_problemtype['problemtype_data']:
        if len(data['description']) != 0:
            d_element = data['description'][0]
            value = ProblemType(d_element['lang'], d_element['value'])
            problemtype_list.append(value)
    return problemtype_list


def description_data(descriptions):
    description_list = []
    for data in descriptions['description_data']:
        # lang = data['lang']
        value = data['value']
        description_list.append(DescriptionType(value))
    return description_list


def affect_vendor_data(cve_affects):
    vendor_list = []
    for data in cve_affects['vendor']['vendor_data']:
        try:
            affect = None
            product_flag = []
            vendor_name = data['vendor_name']
            for product_info in data['product']['product_data']:
                product_name = product_info['product_name']
                for version in product_info['version']['version_data']:
                    version_value = version
                    product_flag.append(product_name + " || " + version_value.get('version_value', 'invaild'))
            affect = Affect(vendor_name, product_flag)
            vendor_list.append(affect)
        except:
            traceback.print_exc()
            continue
    return vendor_list


def reference_data(references):
    reference_list = []
    for data in references['reference_data']:
        url = data['url']
        # name = data['name']
        # refsource = data['refsource']
        reference_list.append(Reference(url))
    return reference_list


def metadata(cve):
    # load cve header metadata
    cve_data_type = cve['data_type']
    cve_data_format = cve['data_format']
    cve_data_version = cve['data_version']

    # load assigner information
    cve_id = cve['CVE_data_meta']['ID']
    cve_assigner = cve['CVE_data_meta']['ASSIGNER']
    return [cve_id, cve_assigner, cve_data_type, cve_data_format, cve_data_version]


class Nvdnist(CVEDatabase):
    def __init__(self, mysql_base):
        super().__init__(mysql_base)
        self._base = mysql_base
        self._worker = None
        self._usuge_thread = 1

    def export(self, export_path_name, export_type, tablename, option="ORDER BY ID, nodes_cpe"):
        return super().export(export_path_name, export_type, tablename, option)

    def load(self, obj):
        # 작업 대상 연도
        year = None
        # RAW 파일명 (경로를 포함하고 있습니다.)
        filename = None
        # RAW 파일을 받을 URL
        url = None
        # RAW 파일 확장자
        filetype = None

        # 파일 지정
        specific_path = None

        thread_count = None

        # 데이터베이스에 연결합니다.
        self.connect()

        # `obj`가 작업을 구성할 인자를 담고 있습니까?
        if isinstance(obj, dict):
            year = obj.get('year')
            # filetype = obj.get('raw_file'', "json")
            filetype = "json"
            specific_path = obj.get("specific_path")
            thread_count = obj.get("thread_count", 2)
        else:
            raise TypeError("The variable 'obj' must be dict, not {t}".format(t=type(obj).__str__()))

        self._usuge_thread = thread_count
        raw_file = None

        if year is None:
            if specific_path is None:
                raise IndentationError(
                    "Cannot running task. The variable `year` is undefined But `specified_path` is also empty")
            else:
                raw_file = specific_path[0]
        else:
            if filetype == "json":
                url = NVD_NIST_JSON_URL
                filename = "nvdcve-1.0-{y}.json.zip".format(y=year)
            elif filetype == "xml":
                # Not support yet.
                url = NVD_NIST_XML_URL
                filename = "nvdcve-2.0-{y}.xml.zip".format(y=year)
                raise NotImplementedError("XML_FILE is not supported yet")

            raw_file = filename.replace(".zip", "")
            is_exist = False

            if not is_exist:
                target_url = url + filename
                print("Downloading compressed resource file ...")
                util.downloadfrom(target_url)

                if os.path.exists(raw_file) is False:
                    util.extract(filename, "./")

        if os.path.exists(raw_file):
            if util.vaildjson(raw_file):
                print("The resource file already exist, continue without the downloed")
                is_exist = True
            else:
                if specific_path is None:
                    os.remove(raw_file)
                    raise IndentationError("Call execption about downloaded file.")
                else:
                    raise IOError("your selected file {file} is not vaild JSON File.".format(file=raw_file))
        else:
            raise IndentationError("{file} is doesn't exist. Unexpected error occured.".format(file=raw_file))

        json_data = open(raw_file, encoding='utf8').read()
        js = json.loads(json_data)
        js_elements = js['CVE_Items']
        collection = []
        print("Identifying values to build with CVE Element ...")
        print("Please wait ...")
        for cve_element in js_elements:
            cve_main = cve_element['cve']
            cve_impact = cve_element['impact']

            # laod metadata
            metadata = metadata(cve_main)

            # load assigner information
            affects_list = affect_vendor_data(cve_main['affects'])

            # load cve main information
            problemtype_list = problemtype_data(cve_main['problemtype'])
            references = reference_data(cve_main['references'])
            descriptions = description_data(cve_main['description'])
            configuration = cve_element.get('configurations', None)

            if configuration is not None:
                cve_data_version = configuration['CVE_data_version']
                cpe_node_list = self.cve_configuration(configuration['nodes'])

            metricv2 = self.get_metric(2, cve_impact)
            metricv3 = self.get_metric(3, cve_impact)

            # load published time
            publishedDate = cve_element["publishedDate"]
            lastModifiedDate = cve_element["lastModifiedDate"]

            data = {
                "metadata": metadata,
                "affects_list": affects_list,
                "problemtype_list": problemtype_list,
                "reference_list": references,
                "description_list": descriptions,
                "cve_data_version": cve_data_version,
                "cpe_node_list": cpe_node_list,
                "metricv2": metricv2,
                "metricv3": metricv3,
                "publishedDate": publishedDate,
                "lastModifiedDate": lastModifiedDate
            }
            jsonData = self.insert(data)
            collection.append(jsonData)
        print('A total of %d CVE elements were found' % len(collection))
        return raw_file, collection

    def default_table_column(self):
        # There's no meaning about variable name.
        # Because it reads automantually only value.
        a2 = TableColumn("year", "VARCHAR(5)")
        a3 = TableColumn("ID", "VARCHAR(24)")
        a4 = TableColumn('ASSIGNER', "VARCHAR(15)")
        a5 = TableColumn("data_type", 'VARCHAR(5)')
        a6 = TableColumn("data_format", "VARCHAR(10)")
        a7 = TableColumn("data_version", "VARCHAR(5)")

        a8 = TableColumn("affects_vendor_name", "TEXT")
        aa8 = TableColumn("affects_product_name", "TEXT")
        ab8 = TableColumn("affects_version_value", "TEXT")
        cpe1 = TableColumn("nodes_operator", "VARCHAR(5)")
        cpe2 = TableColumn("nodes_cpe", "TEXT")
        cpe3 = TableColumn("nodes_cpe_vulnerable", "VARCHAR(5)")
        cpe4 = TableColumn("nodes_cpe_cpe22uri", "TEXT")
        cpe5 = TableColumn("nodes_cpe_cpe23uri", "TEXT")

        ac8 = TableColumn("problemtype", "VARCHAR(25)")
        a9 = TableColumn("description_value", "TEXT")
        a10 = TableColumn("reference_url", "TEXT")
        a11 = TableColumn("cve_data_version", "VARCHAR(5)")
        a13 = TableColumn('baseMetricV2_version', "VARCHAR(10)")
        a14 = TableColumn('baseMetricV2_vectorString', "VARCHAR(50)")
        a15 = TableColumn('baseMetricV2_confidentialityImpact', "VARCHAR(10)")
        a16 = TableColumn('baseMetricV2_availabilityImpact', "VARCHAR(10)")
        a17 = TableColumn('baseMetricV2_baseScore', "VARCHAR(10)")
        a18 = TableColumn('baseMetricV2_exploitabilityScore', "VARCHAR(10)")
        a19 = TableColumn('baseMetricV2_impactScore', "VARCHAR(10)")
        aa19 = TableColumn('baseMetricV2_integrityImpact', "VARCHAR(10)")
        a20 = TableColumn('baseMetricV2_severity', "VARCHAR(10)")
        a21 = TableColumn('baseMetricV2_obtainAllPrivilege', "VARCHAR(10)")
        a22 = TableColumn('baseMetricV2_obtainUserPrivilege', "VARCHAR(10)")
        a23 = TableColumn('baseMetricV2_obtainOtherPrivilege', "VARCHAR(10)")
        a24 = TableColumn('baseMetricV2_userInteractionRequired', "VARCHAR(10)")
        a25 = TableColumn('baseMetricV2_accessVector', "VARCHAR(48)")
        a26 = TableColumn('baseMetricV2_accessComplexity', "VARCHAR(10)")
        a27 = TableColumn('baseMetricV2_authentication', "VARCHAR(10)")

        a28 = TableColumn('baseMetricV3_version', "VARCHAR(10)")
        a29 = TableColumn('baseMetricV3_vectorString', "VARCHAR(50)")
        a30 = TableColumn('baseMetricV3_confidentialityImpact', "VARCHAR(10)")
        a31 = TableColumn('baseMetricV3_integrityImpact', "VARCHAR(10)")
        a32 = TableColumn('baseMetricV3_availabilityImpact', "VARCHAR(10)")
        a33 = TableColumn('baseMetricV3_baseScore', "VARCHAR(10)")
        a34 = TableColumn('baseMetricV3_exploitabilityScore', "VARCHAR(10)")
        a35 = TableColumn('baseMetricV3_impactScore', "VARCHAR(10)")
        a36 = TableColumn('baseMetricV3_attackVector', "VARCHAR(36)")
        a37 = TableColumn('baseMetricV3_attackComplexity', "VARCHAR(10)")
        a38 = TableColumn('baseMetricV3_privilegesRequired', "VARCHAR(10)")
        aa38 = TableColumn('baseMetricV3_userInteraction', "VARCHAR(10)")
        a39 = TableColumn('baseMetricV3_baseSeverity', "VARCHAR(10)")
        a40 = TableColumn('baseMetricV3_scope', "VARCHAR(10)")

        a41 = TableColumn('publishedDate', "VARCHAR(20)")
        a42 = TableColumn('lastModifiedDate', "VARCHAR(20)")
        tables = list(vars().values())
        return tuple(tables)

    def find_key(self, element, pattern):
        p = re.compile(pattern)
        key = []
        for k in element.keys():
            if p.match(k) is not None:
                key.append(k)
        return key

    def table_insert(self, tablename, jsonCollection):
        try:
            result = 0
            finish = 0
            print("USE_MAX_THREAD_COUNT=%d" % self._usuge_thread)
            worker = SQLWorker(workstation).initialize(self._usuge_thread)
            self._worker = worker

            print("Inserting value ...")
            for jsonElement in jsonCollection:
                worker.reserve(self.user, self.password, self.host, self.port, self.database, tablename, jsonElement)

            for ps in worker.as_complete():
                result = result + ps.result()
                finish = finish + 1
                sys.stdout.write("\rFinish CVE(s): %d :: Processed amount: %d" % (finish, result))
                sys.stdout.flush()

            print("\nAll data insert completed.")

            self._worker.terminate()
        except (KeyboardInterrupt, SystemExit):
            self._worker.terminate()
            sys.exit(0)

    def auto_serialize(self, obj, jsonDefault, o=None):
        default_type = {str: True, bool: True, float: True, str: True, int: True}
        if default_type.get(type(obj), False):
            pass
        else:
            try:
                obj.serialize(jsonDefault, o)
            except:
                # It means, there's no value.
                pass

    def list_value_insert(self, dic, jsonDefault, *args):
        if dic is None:
            return

        for name in args:
            if dic.get(name) is None:
                continue
            else:
                for index, value in enumerate(dic.get(name)):
                    self.auto_serialize(value, jsonDefault, index)

    def insert(self, obj):
        jsonDefault = json.loads("{}")

        metadata = obj.get('metadata')
        jsonDefault['cve_id'] = metadata[0]
        jsonDefault['assigner'] = metadata[1]
        jsonDefault['data_type'] = metadata[2]
        jsonDefault['data_format'] = metadata[3]
        jsonDefault['data_version'] = metadata[4]

        self.list_value_insert(obj, jsonDefault, "affects_list", "problemtype_list",
                               "reference_list", "description_list")

        jsonDefault['CVE_data_version'] = obj.get('cve_data_version')

        self.list_value_insert(obj, jsonDefault, "cpe_node_list")
        self.auto_serialize(obj.get('metricv2'), jsonDefault)
        self.auto_serialize(obj.get('metricv3'), jsonDefault)

        jsonDefault["publishedDate"] = obj.get('publishedDate')
        jsonDefault["lastModifiedDate"] = obj.get('lastModifiedDate')
        return jsonDefault

    def get_metric(self, version, element):
        if len(element) == 0:
            return None

        result = None
        if version == 2:
            baseMetric = element['baseMetricV2']
            baseCvss = baseMetric['cvssV2']

            version = baseCvss['version']
            vectorString = baseCvss['vectorString']
            accessVector = baseCvss['accessVector']
            accessComplexity = baseCvss['accessComplexity']
            authentication = baseCvss['authentication']
            confidentialityImpact = baseCvss['confidentialityImpact']
            integrityImpact = baseCvss['integrityImpact']
            availabilityImpact = baseCvss['availabilityImpact']
            baseScore = baseCvss['baseScore']
            severity = baseMetric['severity']
            exploitabilityScore = baseMetric['exploitabilityScore']
            impactScore = baseMetric['impactScore']
            obtainAllPrivilege = baseMetric['obtainAllPrivilege']
            obtainUserPrivilege = baseMetric['obtainUserPrivilege']
            obtainOtherPrivilege = baseMetric['obtainOtherPrivilege']
            try:
                userInteractionRequired = baseMetric['userInteractionRequired']
            except KeyError:
                userInteractionRequired = "NONE"

            cvss = Cvss2(exploitabilityScore, impactScore, severity, obtainAllPrivilege, obtainUserPrivilege,
                         obtainOtherPrivilege, userInteractionRequired)
            result = Metricv2(version, vectorString, accessVector, accessComplexity, authentication,
                              confidentialityImpact, integrityImpact, availabilityImpact, baseScore, cvss)

        elif version == 3:
            baseMetric = None
            try:
                baseMetric = element['baseMetricV3']
            except KeyError:
                pass

            if baseMetric is not None:
                baseCvss = baseMetric['cvssV3']
                version = baseCvss['version']
                vectorString = baseCvss['vectorString']
                attackVector = baseCvss['attackVector']
                attackComplexity = baseCvss['attackComplexity']
                privilegesRequired = baseCvss['privilegesRequired']
                userInteraction = baseCvss['userInteraction']
                scope = baseCvss['scope']
                confidentialityImpact = baseCvss['confidentialityImpact']
                integrityImpact = baseCvss['integrityImpact']
                availabilityImpact = baseCvss['availabilityImpact']
                baseScore = baseCvss['baseScore']
                baseSeverity = baseCvss['baseSeverity']

                exploitabilityScore = baseMetric['exploitabilityScore']
                impactScore = baseMetric['impactScore']

                cvss = BasicCvssElement(exploitabilityScore, impactScore)
                result = Metricv3(version, vectorString, attackVector, attackComplexity, privilegesRequired,
                                  userInteraction, scope, confidentialityImpact, integrityImpact, availabilityImpact,
                                  baseScore, baseSeverity, cvss)
        else:
            raise ValueError("What is this version?")
        return result

    def cve_configuration(self, nodes, ref=None, number=0, isChildren=False):
        n = number
        node_list = None
        if ref is not None:
            node_list = ref
        else:
            node_list = []
        for node in nodes:
            operator = None
            try:
                operator = node['operator']
            except KeyError:
                pass

            if operator == 'AND':
                try:
                    self.cve_configuration(node['children'], node_list, n, True)
                except KeyError:
                    self.cve_configuration(node['cpe'], node_list, n, True)

            elif operator == 'OR':
                keys = node.get('cpe', None)
                if keys is None:
                    keys = node.get('children', None)
                    if keys is None:
                        return
                for cpe in keys:

                    chk = cpe.get('cpe', None)
                    if chk is not None:
                        cpe = chk[0]

                    vulnerable = cpe['vulnerable']
                    cpe22uri = cpe['cpe22Uri']
                    cpe23uri = cpe['cpe23Uri']
                    node_list.append(CPENode(vulnerable, cpe22uri, cpe23uri, n))
            else:
                for node in nodes:
                    vulnerable = node['vulnerable']
                    cpe22uri = node['cpe22Uri']
                    cpe23uri = node['cpe23Uri']
                    node_list.append(CPENode(vulnerable, cpe22uri, cpe23uri, n))
            n = n + 1
        return node_list


class BasicCvssElement:
    def __init__(self, exploitabilityScore, impactScore):
        self.exploitabilityScore = exploitabilityScore
        self.impactScore = impactScore

    def serialize(self, jsonDefault, o):
        baseName = "baseMetricV3."
        for field in self.__dir__():
            value = getattr(self, field)
            if not callable(value) and not field.startswith('__'):
                jsonDefault[baseName + field] = value


class AbstractMetric:
    def __init__(self, version, vectorString, confidentialityImpact, integrityImpact, availabilityImpact, baseScore,
                 cvss):
        self.version = version
        self.vectorString = vectorString
        self.confidentialityImpact = confidentialityImpact
        self.integrityImpact = integrityImpact
        self.availabilityImpact = availabilityImpact
        self.baseScore = baseScore
        self.cvss = cvss


class Cvss2(BasicCvssElement):
    def __init__(self, exploitabilityScore, impactScore, severity, obtainAllPrivilege, obtainUserPrivilege,
                 obtainOtherPrivilege, userInteractionRequired):
        super().__init__(exploitabilityScore, impactScore)
        self.severity = severity
        self.obtainAllPrivilege = obtainAllPrivilege
        self.obtainUserPrivilege = obtainUserPrivilege
        self.obtainOtherPrivilege = obtainOtherPrivilege
        self.userInteractionRequired = userInteractionRequired

    def serialize(self, jsonDefault, o):
        baseName = "baseMetricV2."
        for field in self.__dir__():
            value = getattr(self, field)
            if not callable(value) and not field.startswith('__'):
                jsonDefault[baseName + field] = value


class Metricv2(AbstractMetric):
    def __init__(self, version, vectorString, accessVector, accessComplexity, authentication, confidentialityImpact,
                 integrityImpact, availabilityImpact, baseScore, cvss):
        super().__init__(version, vectorString, confidentialityImpact, integrityImpact, availabilityImpact, baseScore,
                         cvss)
        self.accessVector = accessVector
        self.accessComplexity = accessComplexity
        self.authentication = authentication

    def serialize(self, jsonDefault, o):
        baseName = "baseMetricV2."
        for field in self.__dir__():
            value = getattr(self, field)
            if not callable(value) and not field.startswith('__'):
                if not isinstance(value, BasicCvssElement):
                    jsonDefault[baseName + field] = value
                else:
                    value.serialize(jsonDefault, o)


class Metricv3(AbstractMetric):
    def __init__(self, version, vectorString, attackVector, attackComplexity, privilegesRequired, userInteraction,
                 scope, confidentialityImpact, integrityImpact, availabilityImpact, baseScore, baseSeverity, cvss):
        super().__init__(version, vectorString, confidentialityImpact, integrityImpact, availabilityImpact, baseScore,
                         cvss)
        self.attackVector = attackVector
        self.attackComplexity = attackComplexity
        self.scope = scope
        self.privilegesRequired = privilegesRequired
        self.userInteraction = userInteraction
        self.baseSeverity = baseSeverity

    def serialize(self, jsonDefault, o):
        baseName = "baseMetricV3."
        for field in self.__dir__():
            value = getattr(self, field)
            if not callable(value) and not field.startswith('__'):
                if not isinstance(value, BasicCvssElement):
                    jsonDefault[baseName + field] = value
                else:
                    value.serialize(jsonDefault, o)


class CPENode:
    __dbcolumn__ = "cpe"

    def __init__(self, vulnerable, cpe22uri, cpe23uri, cpe=-1):
        self.vulnerable = vulnerable
        self.cpe22uri = cpe22uri
        self.cpe23uri = cpe23uri
        self.cpe = cpe

    def serialize(self, jsonDefault, o):
        jsonDefault["cpe_" + str(o) + "_vulnderable"] = self.vulnerable
        jsonDefault["cpe_" + str(o) + "_cpe22uri"] = self.cpe22uri
        jsonDefault["cpe_" + str(o) + "_cpe23uri"] = self.cpe23uri
        jsonDefault["cpe_" + str(o) + "_number"] = self.cpe


class Affect:
    def __init__(self, vendor_name, product_flag):
        self.vendor_name = vendor_name
        self.product_flag = product_flag

    def serialize(self, jsonDefault, o):
        for index, flag in enumerate(self.product_flag):
            jsonDefault['affect_{n}'.format(n=index)] = str(self.vendor_name + " || " + flag)


class DescriptionType:
    __dbcolumn__ = "Description"

    def __init__(self, value):
        self.value = value

    def serialize(self, jsonDefault, o):
        jsonDefault["desc_" + str(id(self))] = self.value


class ProblemType(DescriptionType):
    def __init__(self, lang, value):
        super().__init__(value)
        self.lang = lang

    def serialize(self, jsonDefault, o):
        jsonDefault["cwe_" + str(id(self))] = self.lang + ", " + self.value


class Reference:
    def __init__(self, url):
        self.url = url

    def serialize(self, jsonDefault, o):
        jsonDefault["reference_" + id(self)] = self.url
