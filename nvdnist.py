# -*- coding: utf-8 -*-
from cve import CVEDatabase
import database
import util
import json
import sys
import re
import traceback
import os
import signal
import time
import copy
from datetime import datetime
from multiprocessing import Process
from database import TableColumn
from threading import Thread
from cvemysql import initialize
from cvemysql import thread_count

NVD_NIST_JSON_URL = 'https://nvd.nist.gov/feeds/json/cve/1.0/'
NVD_NIST_XML_URL = 'https://nvd.nist.gov/feeds/xml/cve/2.0/'

execption_list = {}

class ThreadList:
    def __init__(self, process):
        self._entry = 0
        self.total = 0
        self._wpList = []
        self.pList = []
        self._coreThread = None
        self._process = None
        self.kill = False
        self.process = process

    def _pobject(self):
        self._entry = len(self._wpList)
        self._wpList.reverse()

        while self.kill == False:
            for ps in range(0, self.process):
                try:
                    v = self._wpList.pop()
                    self.pList.append(v)
                except:
                    if len(self._wpList) != 0:
                        self.process = len(self._wpList) % self.process
                        self._pobject()
                    else:
                        self.kill = True
                        break
            
            for p in self.pList:
                p.start()

            for p in self.pList:
                p.join()

            for p in self.pList:
                del p
        
            self.pList.clear()

            if len(self._wpList) == 0:
                self.kill = True

    def _processFunction(self):
        while self.kill == False:
            sys.stdout.write("\rCurrent progress: %d / %d" % (self._entry - len(self._wpList), self._entry))
            sys.stdout.flush()
            time.sleep(5)
    
    def start(self):
        self._coreThread = Thread(target=self._pobject)
        self._coreThread.start()

        self._process = Thread(target=self._processFunction)
        self._process.start()
            
    def add_thread(self, thread):
        self._wpList.append(thread)

def workstation(sql, tablename, jsonElement):
        try:
            # PyMySQL has thread-safety while a per, So It needs to new connect.
            new_db = initialize(sql.user, sql.password, sql.host, sql.port)
            base = Nvdnist(new_db)
            base.use_database(sql.database)

            cve_id = str(jsonElement['cve_id'])
            p = re.compile(r'CVE-(\d{4})-.+$')
            cve_year = str(p.match(cve_id).group(1))

            assigner = str(jsonElement['assigner'])
            data_type = str(jsonElement['data_type'])
            data_format = str(jsonElement['data_format'])
            data_version = str(jsonElement['data_version'])
            cve_data_version = str(jsonElement['CVE_data_version'])
            reference = ""
            description = ""
            cpe = ""
            problemtype = ""

            for r in base.find_key(jsonElement, r"reference_.+$"):
                reference += jsonElement[r] + " || "
            reference = reference[:-4]

            for d in base.find_key(jsonElement, r"desc_(.+)"):
                description += jsonElement[d] + " || "
            description = description[:-4]

            for d in base.find_key(jsonElement, r"cwe_\d"):
                problemtype += jsonElement[d] + " || "
            problemtype = problemtype[:-4]

            cpe_list = []

            for c in base.find_key(jsonElement, r"cpe_\d_vulnderable"):
                cpe_list.append(str(jsonElement[c]) + "|")

                
            for index, c in enumerate(base.find_key(jsonElement, r"cpe_\d_cpe22uri")):
                cpe_list[index] += (str(jsonElement[c])) + "|"


            for index, c in enumerate(base.find_key(jsonElement, r"cpe_\d_cpe23uri")):
                cpe_list[index] += (str(jsonElement[c]))

            for c in cpe_list:
                cpe += c + " || "
            cpe = cpe[:-4]
                
                # for version 2
            baseMetricV2_version = str(jsonElement.get('baseMetricV2.version', ''))
            baseMetricV2_vectorString = str(jsonElement.get('baseMetricV2.vectorString', ''))
            baseMetricV2_accessVector = str(jsonElement.get('baseMetricV2.accessVector', ''))
            baseMetricV2_accessComplexity = str(jsonElement.get('baseMetricV2.accessComplexity', ''))
            baseMetricV2_authentication = str(jsonElement.get('baseMetricV2.authentication', ''))
            baseMetricV2_confidentialityImpact = str(jsonElement.get('baseMetricV2.confidentialityImpact', ''))
            baseMetricV2_integrityImpact = str(jsonElement.get('baseMetricV2.integrityImpact', ''))
            baseMetricV2_availabilityImpact = str(jsonElement.get('baseMetricV2.availabilityImpact', ''))
            baseMetricV2_baseScore = str(jsonElement.get('baseMetricV2.baseScore', ''))
            baseMetricV2_severity = str(jsonElement.get('baseMetricV2.severity', ''))
            baseMetricV2_exploitabilityScore = str(jsonElement.get('baseMetricV2.exploitabilityScore', ''))
            baseMetricV2_impactScore = str(jsonElement.get('baseMetricV2.impactScore', ''))
            baseMetricV2_obtainAllPrivilege = str(jsonElement.get('baseMetricV2.obtainAllPrivilege', ''))
            baseMetricV2_obtainUserPrivilege = str(jsonElement.get('baseMetricV2.obtainUserPrivilege', ''))
            baseMetricV2_obtainOtherPrivilege = str(jsonElement.get('baseMetricV2.obtainOtherPrivilege', ''))
            baseMetricV2_userInteractionRequired = str(jsonElement.get('baseMetricV2.userInteractionRequired', ''))
                
            # for version 3
            baseMetricV3_version = str(jsonElement.get('baseMetricV3.version', ''))
            baseMetricV3_vectorString = str(jsonElement.get('baseMetricV3.vectorString', ''))
            baseMetricV3_attackVector = str(jsonElement.get('baseMetricV3.attackVector', ''))
            baseMetricV3_attackComplexity = str(jsonElement.get('baseMetricV3.attackComplexity', ''))
            baseMetricV3_privillegesRequired = str(jsonElement.get('baseMetricV3.privillegesRequired', ''))
            baseMetricV3_userInteraction = str(jsonElement.get('baseMetricV3.userInteraction', ''))

            baseMetricV3_scope = str(jsonElement.get('baseMetricV3.scope', ''))
            baseMetricV3_confidentialityImpact = str(jsonElement.get('baseMetricV3.confidentialityImpact', ''))
            baseMetricV3_integrityImpact = str(jsonElement.get('baseMetricV3.integrityImpact', ''))
            baseMetricV3_availabilityImpact = str(jsonElement.get('baseMetricV3.availabilityImpact', ''))
            baseMetricV3_baseScore = str(jsonElement.get('baseMetricV3.baseScore', ''))
            baseMetricV3_baseSeverity = str(jsonElement.get('baseMetricV3.baseSeverity', ''))
            baseMetricV3_exploitabilityScore = str(jsonElement.get('baseMetricV3.exploitabilityScore', ''))
            baseMetricV3_impactScore = str(jsonElement.get('baseMetricV3.impactScore', ''))

            publishedDate = str(jsonElement.get('publishedDate', ''))
            lastModifiedDate = str(jsonElement.get('lastModifiedDate', ''))

            affect = ""
            for index, c in enumerate(base.find_key(jsonElement, r"affect_\d")):
                affect += jsonElement[c] + " || "
            affect = affect[:-4]

            a = None
            r = None
            d = None
            c = None
            query_argument = None
            query_format = None
            query_argument = None
            query_header = None
            variable_name = None

            v = dict(vars())
            
            query_header = "("
            query_format = "("
            query_argument = []
            # automatic insert value
            for variable_name in v.keys():
                if isinstance(v[variable_name], str) and not variable_name == "tablename":
                    query_header += variable_name + ','
                    query_format += "%s,"
                    query_argument.append(v[variable_name])
            query_header = query_header[:-1]
            query_header += ")"
            query_format = query_format[:-1]
            query_format += ")"
            sucessful = base.send_query("INSERT INTO {table_name} {header} VALUES {format}".format(table_name=tablename, header=query_header, format=query_format), tuple(query_argument), False, execption_list)
            base.disconnect()
        except KeyboardInterrupt:
            sys.exit()
        except SystemExit:
            sys.exit()

def handler(signal, frame):
    print("KILLED: %s %s" % (signal, frame))
    

class Nvdnist(CVEDatabase):
    def __init__(self, mysql_base):
        super().__init__(mysql_base)

    
    def export(self, export_path_name, export_type, tablename, option="ORDER BY cve_id"):
        return super().export(export_path_name, export_type, tablename, option)

    def load(self, obj):
        signal.signal(signal.SIGTERM, handler)

        # 작업 대상 연도
        year = None
        # RAW 파일명 (경로를 포함하고 있습니다.)
        filename = None
        # RAW 파일을 받을 URL
        url = None
        # RAW 파일 확장자
        filetype = None
        
        # 파일 지정
        specific_path = None
        
        # 데이터베이스에 연결합니다.
        self.connect()

        # `obj`가 작업을 구성할 인자를 담고 있습니까?
        if isinstance(obj, dict):
            year = obj.get('year')
            # filetype = obj.get('raw_file'', "json")
            filetype = "json"
            specific_path = obj.get("specific_path")
        else:
            raise TypeError("The variable 'obj' must be dict, not {t}".format(t=type(obj).__str__()))

        raw_file = None

        if year is None:
            if specific_path is None:
                raise IndentationError("Cannot running task. The variable `year` is undefined But `specified_path` is also empty")
            else:
                raw_file = specific_path[0]
        else:
            if filetype == "json":
                url = NVD_NIST_JSON_URL
                filename = "nvdcve-1.0-{y}.json.zip".format(y=year)
            elif filetype == "xml":
                # Not support yet.
                url = NVD_NIST_XML_URL
                filename = "nvdcve-2.0-{y}.xml.zip".format(y=year)
                raise NotImplementedError("XML_FILE is not supported yet")

            raw_file = filename.replace(".zip", "")
            is_exist = False

            if not is_exist:
                target_url = url + filename
                print("Downloading compressed resource file ...")
                util.downloadfrom(target_url)

                if os.path.exists(raw_file) is False:
                    util.extract(filename, "./")
        if os.path.exists(raw_file):
            if util.vaildjson(raw_file):
                print("The resource file already exist, continue without the downloed")
                is_exist = True
            else:
                if specific_path is None:
                    os.remove(raw_file)
                    raise IndentationError("Call execption about downloaded file.")
                else:
                    raise IOError("your selected file {file} is not vaild JSON File.".format(file=raw_file))
        else:
            raise IndentationError("{file} is doesn't exist. Unexpected error occured.".format(file=raw_file))

        json_data = open(raw_file, encoding='utf8').read()
        js = json.loads(json_data)
        js_elements = js['CVE_Items']
        collection = []
        print("Identifying values to build with CVE Element ...")
        print("Please wait ...")
        for cve_element in js_elements:
            cve_main = cve_element['cve']
            cve_impact = cve_element['impact']

            # laod metadata
            metadata = self.metadata(cve_main)

            # load assigner information
            affects_list = self.affect_vendor_data(cve_main['affects'])
            
            # load cve main information
            problemtype_list = self.problemtype_data(cve_main['problemtype'])
            references = self.reference_data(cve_main['references'])
            descriptions = self.description_data(cve_main['description'])
            configuration = cve_element.get('configurations', None)

            if configuration is not None:
                cve_data_version = configuration['CVE_data_version']
                cpe_node_list = self.cve_configuration(configuration['nodes'])
                
            metricv2 = self.get_metric(2, cve_impact)
            metricv3 = self.get_metric(3, cve_impact)

            # load published time
            publishedDate = cve_element["publishedDate"]
            lastModifiedDate = cve_element["lastModifiedDate"]

            data = {
                "metadata": metadata,
                "affects_list": affects_list,
                "problemtype_list": problemtype_list,
                "reference_list": references,
                "description_list": descriptions,
                "cve_data_version": cve_data_version,
                "cpe_node_list": cpe_node_list,
                "metricv2": metricv2,
                "metricv3": metricv3,
                "publishedDate": publishedDate,
                "lastModifiedDate": lastModifiedDate
            }
            jsonData = self.insert(data)
            collection.append(jsonData)
        print('A total of %d CVE elements were found' % len(collection))
        return raw_file, collection
    
    def default_table_column(self):
        a1 = TableColumn("_number", "INT PRIMARY KEY AUTO_INCREMENT")
        a2 = TableColumn("cve_year", "VARCHAR(5)")

        a3 = TableColumn("cve_id", "VARCHAR(24)")
        a4 = TableColumn('assigner', "VARCHAR(15)")
        a5 = TableColumn("data_type", 'VARCHAR(5)')
        a6 = TableColumn("data_format", "VARCHAR(10)")
        a7 = TableColumn("data_version", "VARCHAR(5)")
        a8 = TableColumn("affect", "TEXT")
        aa8 = TableColumn("problemtype", "VARCHAR(25)")
        a9 = TableColumn("description", "TEXT")
        a10 = TableColumn("reference", "TEXT")
        a11 = TableColumn("cve_data_version", "VARCHAR(5)")
        a12 = TableColumn("cpe", "TEXT")
        
        a13 = TableColumn('baseMetricV2_version', "VARCHAR(10)")
        a14 = TableColumn('baseMetricV2_vectorString', "VARCHAR(50)")
        a15 = TableColumn('baseMetricV2_confidentialityImpact', "VARCHAR(10)")
        a16 = TableColumn('baseMetricV2_availabilityImpact', "VARCHAR(10)")
        a17 = TableColumn('baseMetricV2_baseScore', "VARCHAR(10)")
        a18 = TableColumn('baseMetricV2_exploitabilityScore', "VARCHAR(10)")
        a19 = TableColumn('baseMetricV2_impactScore', "VARCHAR(10)")
        aa19 = TableColumn('baseMetricV2_integrityImpact', "VARCHAR(10)")
        a20 = TableColumn('baseMetricV2_severity', "VARCHAR(10)")
        a21 = TableColumn('baseMetricV2_obtainAllPrivilege', "VARCHAR(10)")
        a22 = TableColumn('baseMetricV2_obtainUserPrivilege', "VARCHAR(10)")
        a23 = TableColumn('baseMetricV2_obtainOtherPrivilege', "VARCHAR(10)")
        a24 = TableColumn('baseMetricV2_userInteractionRequired', "VARCHAR(10)")
        a25 = TableColumn('baseMetricV2_accessVector', "VARCHAR(48)")
        a26 = TableColumn('baseMetricV2_accessComplexity', "VARCHAR(10)")
        a27 = TableColumn('baseMetricV2_authentication', "VARCHAR(10)")

        a28 = TableColumn('baseMetricV3_version', "VARCHAR(10)")
        a29 = TableColumn('baseMetricV3_vectorString', "VARCHAR(50)")
        a30 = TableColumn('baseMetricV3_confidentialityImpact', "VARCHAR(10)")
        a31 = TableColumn('baseMetricV3_integrityImpact', "VARCHAR(10)")
        a32 = TableColumn('baseMetricV3_availabilityImpact', "VARCHAR(10)")
        a33 = TableColumn('baseMetricV3_baseScore', "VARCHAR(10)")
        a34 = TableColumn('baseMetricV3_exploitabilityScore', "VARCHAR(10)")
        a35 = TableColumn('baseMetricV3_impactScore', "VARCHAR(10)")
        a36 = TableColumn('baseMetricV3_attackVector', "VARCHAR(36)")
        a37 = TableColumn('baseMetricV3_attackComplexity', "VARCHAR(10)")
        a38 = TableColumn('baseMetricV3_privillegesRequired', "VARCHAR(10)")
        aa38 = TableColumn('baseMetricV3_userInteraction', "VARCHAR(10)")
        a39 = TableColumn('baseMetricV3_baseSeverity', "VARCHAR(10)")
        a40 = TableColumn('baseMetricV3_scope', "VARCHAR(10)")

        a41 = TableColumn('publishedDate', "VARCHAR(20)")
        a42 = TableColumn('lastModifiedDate', "VARCHAR(20)")
        tables = list(vars().values())
        return tuple(tables)
    

    def find_key(self, element, pattern):
        p = re.compile(pattern)
        key = []
        for k in element.keys():
            if p.match(k) is not None:
                key.append(k)
        return key

    def table_insert(self, tablename, jsonCollection):
        try:
            print("MYSQL inserting thread now started")
            threadlist = ThreadList(thread_count)
            print("Inserting value ...")
            for jsonElement in jsonCollection:
                p = Thread(target=workstation, args=(self, tablename, jsonElement))
                threadlist.add_thread(p)
            threadlist.start()
            while threadlist.kill == False:
                time.sleep(0.1)
        except (KeyboardInterrupt, SystemExit):
            sys.exit(-1)


        if len(execption_list) != 0:
            filename = "err-{time}.log".format(time=datetime.now()).replace(" ", "").replace(":", ".")
            current_key = list(execption_list.keys())
            with open(filename, 'w+', encoding='utf-8') as fs:
                for ex in current_key:
                    for v in list(execption_list.get(ex)):
                        if isinstance(v, str) and re.compile("CVE-.").match(v):
                            value = v
                            fs.write("실패: Column에 값을 넣을 수 없습니다. -> {cve} | Reason: {r}\n".format(cve=v, r=ex))
                            break
                fs.close()
                execption_list.clear()
            print("\n경고: \n{count} elements could not be inserted into the table. See {f} for more reasons.".format(count=len(execption_list), f=filename))
            
        print("\nAll data has been inserted.")

        
    def auto_serialize(self, obj, jsonDefault, o=None):
        default_type = {str: True,bool: True,float: True,str: True,int: True}
        if default_type.get(type(obj), False):
            pass
        else:
            try:
                obj.serialize(jsonDefault, o)
            except:
                # It means, there's no value.
                pass

    def list_value_insert(self, dic, jsonDefault, *args):
        if dic is None:
            return

        for name in args:
            if dic.get(name) is None:
                continue
            else:
                for index, value in enumerate(dic.get(name)):
                    self.auto_serialize(value, jsonDefault, index)
    
    def insert(self, obj):
        jsonDefault = json.loads("{}")

        metadata = obj.get('metadata')
        jsonDefault['cve_id']       = metadata[0]
        jsonDefault['assigner']     = metadata[1]
        jsonDefault['data_type']    = metadata[2]
        jsonDefault['data_format']  = metadata[3]
        jsonDefault['data_version'] = metadata[4]

        self.list_value_insert(obj, jsonDefault, "affects_list", "problemtype_list",
         "reference_list", "description_list")

        jsonDefault['CVE_data_version'] = obj.get('cve_data_version')

        self.list_value_insert(obj, jsonDefault, "cpe_node_list")
        self.auto_serialize(obj.get('metricv2'), jsonDefault)
        self.auto_serialize(obj.get('metricv3'), jsonDefault)

        jsonDefault["publishedDate"] = obj.get('publishedDate')
        jsonDefault["lastModifiedDate"] = obj.get('lastModifiedDate')
        return jsonDefault


    def get_metric(self, version, element):
        if len(element) == 0:
            return None

        result = None
        if version == 2:
            baseMetric = element['baseMetricV2']
            baseCvss = baseMetric['cvssV2']

            version = baseCvss['version']
            vectorString = baseCvss['vectorString']
            accessVector = baseCvss['accessVector']
            accessComplexity = baseCvss['accessComplexity']
            authentication = baseCvss['authentication']
            confidentialityImpact = baseCvss['confidentialityImpact']
            integrityImpact = baseCvss['integrityImpact']
            availabilityImpact = baseCvss['availabilityImpact']
            baseScore = baseCvss['baseScore']
            severity = baseMetric['severity']
            exploitabilityScore = baseMetric['exploitabilityScore']
            impactScore = baseMetric['impactScore']
            obtainAllPrivilege = baseMetric['obtainAllPrivilege']
            obtainUserPrivilege = baseMetric['obtainUserPrivilege']
            obtainOtherPrivilege = baseMetric['obtainOtherPrivilege']
            try:
                userInteractionRequired = baseMetric['userInteractionRequired']
            except KeyError:
                userInteractionRequired = "NONE"

            cvss = Cvss2(exploitabilityScore, impactScore, severity, obtainAllPrivilege, obtainUserPrivilege, obtainOtherPrivilege, userInteractionRequired)
            result = Metricv2(version, vectorString, accessVector, accessComplexity, authentication, confidentialityImpact, integrityImpact, availabilityImpact, baseScore, cvss)
        
        elif version == 3:
            baseMetric = None
            try:
                baseMetric = element['baseMetricV3']
            except KeyError:
                pass

            if baseMetric is not None:
                baseCvss = baseMetric['cvssV3']
                version = baseCvss['version']
                vectorString = baseCvss['vectorString']
                attackVector = baseCvss['attackVector']
                attackComplexity = baseCvss['attackComplexity']
                privilegesRequired = baseCvss['privilegesRequired']
                userInteraction = baseCvss['userInteraction']
                scope = baseCvss['scope']
                confidentialityImpact = baseCvss['confidentialityImpact']
                integrityImpact = baseCvss['integrityImpact']
                availabilityImpact = baseCvss['availabilityImpact']
                baseScore = baseCvss['baseScore']
                baseSeverity = baseCvss['baseSeverity']
                
                exploitabilityScore = baseMetric['exploitabilityScore']
                impactScore = baseMetric['impactScore']

                cvss = BasicCvssElement(exploitabilityScore, impactScore)
                result = Metricv3(version, vectorString, attackVector, attackComplexity, privilegesRequired, userInteraction, scope, confidentialityImpact, integrityImpact, availabilityImpact, baseScore, baseSeverity, cvss)
        else:
            raise ValueError("What is this version?")
        return result
    
    def metadata(self, cve):
        # load cve header metadata
        cve_data_type = cve['data_type']
        cve_data_format = cve['data_format']
        cve_data_version = cve['data_version']

        # load assigner information
        cve_id = cve['CVE_data_meta']['ID']
        cve_assigner = cve['CVE_data_meta']['ASSIGNER']
        return [cve_id, cve_assigner, cve_data_type, cve_data_format, cve_data_version]

    def cve_configuration(self, nodes, ref=None):
        node_list = None
        if ref is not None:
            node_list = ref
        else:
            node_list = []
        for node in nodes:
            operator = None
            try:
                operator = node['operator']
            except KeyError:
                pass

            if operator == 'AND':
                try:
                    self.cve_configuration(node['children'], node_list)
                except KeyError:
                    self.cve_configuration(node['cpe'], node_list)
            
            elif operator == 'OR':
                keys = node.get('cpe', None)
                if keys is None:
                    keys = node.get('children', None)
                    if keys is None:
                        return
                for cpe in keys:
                    chk = cpe.get('cpe', None)
                    if chk is not None:
                        cpe = chk[0]
                    vulnerable = cpe['vulnerable']
                    cpe22uri = cpe['cpe22Uri']
                    cpe23uri = cpe['cpe23Uri']
                    node_list.append(CPENode(vulnerable, cpe22uri, cpe23uri))
            else:
                for node in nodes:
                    vulnerable = node['vulnerable']
                    cpe22uri = node['cpe22Uri']
                    cpe23uri = node['cpe23Uri']
                    node_list.append(CPENode(vulnerable, cpe22uri, cpe23uri))
        return node_list

    def reference_data(self, references):
        reference_list = []
        for data in references['reference_data']:
            url = data['url']
            name = data['name']
            refsource = data['refsource']
            reference_list.append(Reference(url, name, refsource))
        return reference_list

    def description_data(self, descriptions):
        description_list = []
        for data in descriptions['description_data']:
            lang = data['lang']
            value = data['value']
            description_list.append(DescriptionType(lang, value))
        return description_list

    def problemtype_data(self, cve_problemtype):
        problemtype_list = []
        for data in cve_problemtype['problemtype_data']:
            if len(data['description']) != 0:
                d_element = data['description'][0]
                value = ProblemType(d_element['lang'], d_element['value'])
                problemtype_list.append(value)
        return problemtype_list
    
    def affect_vendor_data(self, cve_affects):
        vendor_list = []
        for data in cve_affects['vendor']['vendor_data']:
            try:
                affect = None
                product_flag = []
                vendor_name = data['vendor_name']
                for product_info in data['product']['product_data']:
                    product_name = product_info['product_name']
                    for version in product_info['version']['version_data']:
                        version_value = version
                        product_flag.append(product_name + ":" + version_value.get('version_value', 'invaild')) 
                affect = Affect(vendor_name, product_flag)
                vendor_list.append(affect)
            except:
                traceback.print_exc()
                continue
        return vendor_list
        
class BasicCvssElement:
    def __init__(self, exploitabilityScore, impactScore):
        self.exploitabilityScore = exploitabilityScore
        self.impactScore = impactScore

    def serialize(self, jsonDefault, o):
        baseName = "baseMetricV3."
        for field in self.__dir__():
            value = getattr(self, field)
            if not callable(value) and not field.startswith('__'):
                jsonDefault[baseName + field] = value

class AbstractMetric:
    def __init__(self, version, vectorString, confidentialityImpact, integrityImpact, availabilityImpact, baseScore, cvss):
        self.version = version
        self.vectorString = vectorString
        self.confidentialityImpact = confidentialityImpact
        self.integrityImpact = integrityImpact
        self.availabilityImpact = availabilityImpact
        self.baseScore = baseScore
        self.cvss = cvss

class Cvss2(BasicCvssElement):
    def __init__(self, exploitabilityScore, impactScore, severity, obtainAllPrivilege, obtainUserPrivilege, obtainOtherPrivilege, userInteractionRequired):
        super().__init__(exploitabilityScore, impactScore)
        self.severity = severity
        self.obtainAllPrivilege = obtainAllPrivilege
        self.obtainUserPrivilege = obtainUserPrivilege
        self.obtainOtherPrivilege = obtainOtherPrivilege
        self.userInteractionRequired = userInteractionRequired

    def serialize(self, jsonDefault, o):
        baseName = "baseMetricV2."
        for field in self.__dir__():
            value = getattr(self, field)
            if not callable(value) and not field.startswith('__'):
                jsonDefault[baseName + field] = value
    
class Metricv2(AbstractMetric):
    def __init__(self, version, vectorString, accessVector, accessComplexity, authentication, confidentialityImpact, integrityImpact, availabilityImpact, baseScore, cvss):
        super().__init__(version, vectorString, confidentialityImpact, integrityImpact, availabilityImpact, baseScore, cvss)
        self.accessVector = accessVector
        self.accessComplexity = accessComplexity
        self.authentication = authentication

    def serialize(self, jsonDefault, o):
        baseName = "baseMetricV2."
        for field in self.__dir__():
            value = getattr(self, field)
            if not callable(value) and not field.startswith('__'):
                if not isinstance(value, BasicCvssElement):
                    jsonDefault[baseName + field] = value
                else:
                    value.serialize(jsonDefault, o)

class Metricv3(AbstractMetric):
    def __init__(self, version, vectorString, attackVector, attackComplexity, privillegesRequired, userInteraction, scope, confidentialityImpact, integrityImpact, availabilityImpact, baseScore, baseSeverity, cvss):
        super().__init__(version, vectorString, confidentialityImpact, integrityImpact, availabilityImpact, baseScore, cvss)
        self.attackVector = attackVector
        self.attackComplexity = attackComplexity
        self.scope = scope
        self.privillegesRequired = privillegesRequired
        self.userInteraction = userInteraction
        self.baseSeverity = baseSeverity

    def serialize(self, jsonDefault, o):
        baseName = "baseMetricV3."
        for field in self.__dir__():
            value = getattr(self, field)
            if not callable(value) and not field.startswith('__'):
                if not isinstance(value, BasicCvssElement):
                    jsonDefault[baseName + field] = value
                else:
                    value.serialize(jsonDefault, o)

class CPENode:
    __dbcolumn__ = "cpe"
    def __init__(self, vulnerable, cpe22uri, cpe23uri):
        self.vulnerable =vulnerable
        self.cpe22uri = cpe22uri
        self.cpe23uri = cpe23uri

    def serialize(self, jsonDefault, o):
        jsonDefault["cpe_" + str(o) + "_vulnderable"] = self.vulnerable
        jsonDefault["cpe_" + str(o) + "_cpe22uri"] = self.cpe22uri
        jsonDefault["cpe_" + str(o) + "_cpe23uri"] = self.cpe23uri


class Affect:
    def __init__(self, vendor_name, product_flag):
        self.vendor_name = vendor_name
        self.product_flag = product_flag
    
    def serialize(self, jsonDefault, o):
        for index, flag in enumerate(self.product_flag):
            jsonDefault['affect_{n}'.format(n=index)] = str(self.vendor_name + ":" + flag)

class DescriptionType:
    __dbcolumn__ = "Description"
    def __init__(self, lang, value):
        self.lang = lang
        self.value = value

    def serialize(self, jsonDefault, o):
            jsonDefault["desc_" + str(id(self))] = self.lang + "|" + self.value

class ProblemType(DescriptionType):
    def __init__(self, lang, value):
        super().__init__(lang, value)

    def serialize(self, jsonDefault, o):
        jsonDefault["cwe_" + str(id(self))] = self.lang + "|" + self.value

class Reference:
    def __init__(self, url, name, refsource):
        self.url = url
        self.name = name
        self.refsource = refsource

    def serialize(self, jsonDefault, o):
            jsonDefault["reference_" + self.name] = self.url + "|" + self.refsource