# -*- coding: utf-8 -*-
import util
import sys
import os
import cvemitre
import nvdnist
import platform
import re
import zipfile
import getpass
import pymysql
from datetime import datetime
from database import MySqlBase

""" 출력 파일의 인자명을 확장자명으로 가져올 수 있는 dict입니다. """
export_file = {'--csv':'csv', '--db':'sql'}

""" 멀티쓰레딩 기반으로 하는 작업을 수행할 때, 사용할 쓰레드의 갯수를 설정합니다. 
    이 값을 임의적으로 바꾸는 것은 권장하지 않습니다.
"""

class CommandException(Exception):
    """ 올바르지 않은 명령어를 입력했을 때 발생하는 예외 처리입니다. """
    def __init__(self, error):
        super().__init__(error)


def initialize(user, password, host, port, char="utf8"):
    """ 사용할 데이터베이스에 연결하고 작업이 이루어질 수 있는 환경을 객체화하여 반환합니다. """
    if password is None:
        password = getpass.getpass('Please input your password {u}@{h} > '.format(u=user, h=host))
    database = MySqlBase(user, password, host, port)
    database.connect()
    return database

def configure_task(base, table_name, year, output_name=None, specific_path=None):
    """ 작업을 구성합니다. """

    # 작업을 위한 여러가지 환경 변수를 지정해줍니다.
    directory = {"year":year,
     "table_name":table_name, "output_name":output_name, "specific_path": specific_path}
    
    # 데이터를 분석하고 이에 따른 결과값을 가져옵니다.
    filepath, collection = base.load(directory)
    
    # 프로그램 실행 시 등록한 데이터베이스 이름을 사용할 데이터베이스로 지정합니다.
    base.use_database(base.database)

    # 테이블에 값을 넣습니다.
    base.table_insert(table_name, collection)

    # 넣은 값을 최종 저장합니다.
    base.save()
    return filepath

def help(error=None):
    """ 인자값이 없거나 초기 실행시 예외처리가 발생하면 출력되는 도움알입니다. """

    print('')
    print("Using command: python cvemysql.py [-u user] [-p password] [-y year] [output_name] [--cofigurations] ...")
    print('')

    print('Requiremenet arguements:')
    print('[-y year] Select year(s)')
    print('')

    print('Option arguments:')
    print('[-u user] [-p password] [-i ip] [-port] [-t tablename] [-d dbname] [-c content] [-port] [-file] ...')
    print('')

    print('Configuration arguements:')
    print('[--year-all] [--csv] [--db]')
    print('')
    print('More description? https://github.com/Ruskonert/cve-mysql-python')
    print('')

    if error is not None:
        raise CommandException(error)

thread_count = 8

if __name__ == "__main__":

    # 특정 파일이 지정되지 않았을 때, 외부에서 CVE RAW 데이터에 해당하는 연도를 담을 리스트입니다.
    list_year = []

    # 데이터를 파일로 출력할 때 사용되는 확장자들을 담을 리스트입니다.
    output_filetype = []

    # 프로그램 인자값, 출력 파일명
    argv, filename =  util.disting_args(sys.argv[1:], '--year-all', '--csv', '--db')

    # 프로그램 환경 식별
    # 쓰레드 갯수 식별
    thread_count = int(util.define_argument_value(argv, "-thread-count", 4, flag="-tc"))

    # RAW 파일 경로 여부
    file_path = util.define_argument_value(argv, "-file", None)
    

    # 구성 인자값 식별
    all_years = util.define_argument_value(argv, "--all-year", False)
    all_source = util.define_argument_value(argv, "--all",  False)
    csv_output = util.define_argument_value(argv, "--csv", False)
    sql_output = util.define_argument_value(argv, "--db", False)

    # 계정 인자값 식별
    user = util.define_argument_value(argv, "-user", flag="-u")
    password = util.define_argument_value(argv, "-password", flag="-p")
    host = util.define_argument_value(argv, "-ip", flag="-i")
    port = util.define_argument_value(argv, "-port")
    content_type = util.define_argument_value(argv, "-content", flag="-c")

    # 데이터베이스 이름 식별
    database_name = util.define_argument_value(argv, "-dbname", flag="-d")
    table_name = util.define_argument_value(argv, "-tablename", flag="-t")


    # 압축 파일 생성 여부
    zip_file = False

    # 연도 별 작업 요구 여부
    year_based_task = True

    # 계정 및 호스트 정보 None 타입 검사
    if user is None:
        user = "root"
        print("경고: 유저명이 지정되지 않았습니다. root라고 가정합니다.")
    
    if password is None:
        print("경고: 비밀번호가 지정되지 않았습니다. 비밀번호를 콘솔 메세지를 통해 요구될 수 있습니다.")

    if host is None:
        host = "127.0.0.1"
        print("경고: MySQL 서버 주소가 지정되지 않았습니다. localhost라고 가정합니다.")
    
    if port is None:
        port = "3306"
        print("경고: MySQL 서버 포트가 지정되지 않았습니다. 3306번 포트를 사용한다고 가정합니다.")

    if database_name is None:
        database_name = "CVE_DATABASE"
        print("경고: 데이터베이스 이름이 지정되지 않았습니다. 데이터베이스 이름을 'CVE_DATABASE'로 설정합니다.")

    if table_name is None:
        table_name = "DATABASE_TABLE"
        print("경고: 데이터베이스 테이블 이름이 지정되지 않았습니다. 테이블 이름을 'DATABASE_TABLE'로 설정합니다.")

    if content_type is None:
        content_type = "nvd"
        print("경고: 컨텐츠 타입이 지정되지 않았습니다. NVD로 자동 설정합니다.")

    if file_path is not None:
        file_path_list = file_path.split(';')

        if len(file_path_list) <= 1:
            file_path_list = [file_path]
        file_path = []
        ENVPATH = os.environ.items()
        for p in file_path_list:
            for value in ENVPATH:
                name, variable = value
                if '$'+name in p:
                    p = p.replace('$'+name, variable).replace("\\", "/")
            file_path.append(p)
        if len(file_path) > 0:
            year_based_task = False
    else:
        print("정보: 지정된 파일 경로가 없습니다. 제공자 사이트에서 데이터를 가져옵니다. 이 경우에는 별도의 인터넷 환경이 요구될 수 있습니다.")
    
    if content_type == "mitre":
        year_based_task = False

    # 연도 식별
    year = util.define_argument_value(argv, "-year", flag="-y")

    if year is None:
        if year_based_task:
            help("년도가 지정되지 않았습니다: 'year' is missing value")
    else:
        if not year_based_task:
            print("경고: 외부로부터 데이터를 가져오지 않습니다. -year와 관련한 모든 인자값을 사용하지 않습니다.")
        else:
            if all_years:
                print("경고: 이미 모든 년도를 대상으로 지정하였습니다. -year 인자값이 무시되었습니다.")
            else:
                try:
                    sp = year.split('-')
                    for target in range(int(sp[0]), int(sp[1]) + 1):
                        list_year.append(target)
                except:
                    if util.isnumber(year):
                        list_year.append(int(year))
                    else:
                        help('올바르지 않은 연도 값입니다.')

    # MITRE 컨텐츠를 이용합니까?
    # if content_type == 'mitre' and len(list_year) != 0:
    #     print("경고: mitre 리스트에서는 연도 별로 구분하지 않습니다. -year와 관련한 모든 인자값을 사용하지 않습니다.")

    # CSV 파일 출력 여부
    if csv_output:
        output_filetype.append(export_file.get("--csv"))

    # SQL 파일 출력 여부 (DB)
    if sql_output:
        output_filetype.append(export_file.get('--db'))

    # 출력 파일명이 2개 이상 지정되어 있습니까?
    if len(filename) >= 2:
        print("경고: 출력 파일 이름이 2개 이상 지정되어 있습니다. 2번째 이름 인자부터 값이 무시됩니다.")
        filename = filename[0]

    elif len(filename) == 0:
        print("경고: 출력 파일 이름이 지정되지 않았습니다. 기본 출력 파일명으로 사용합니다.")
        filename = None
    else:
        filename = filename[0]

    # 출력 파일명 검증
    if filename is not None:
        # 출력 파일명에 ZIP 확장자를 포함하고 있습니까?
        if filename.endswith('.zip'):
            zip_file = True
            filename = filename.replace('.zip', '')
    else:
        # 출력 파일명 지정 안됨
        pass

    if len(output_filetype) == 0 and filename is not None:
        print("경고: 출력하는 파일 형식이 1개 이상 지정되지 않았으나 파일명이 지정되어 있습니다. 이 경우 무시됩니다.")
    
    # MySQL 데이터베이스 객체를 초기화하고 생성합니다.
    db = initialize(user, password, host, port)
    print("Connected the MySQL Database {u}@{h}".format(u=user, h=host))

    # 초기화 실패
    if db is None:
        raise pymysql.DatabaseError("Something wrong. The initialize of MySQL Object was failed.")

    # 데이터베이스 생성 여부 확인    
    print("데이터베이스 여부를 확인합니다: {name} ...".format(name=database_name))
    if db.create_database(database_name):
        print("데이터베이스를 새로 생성하였습니다: {name}".format(name=database_name))

    if content_type == "nvd":
        # NIST 데이터베이스 형식으로 연결
        base = nvdnist.Nvdnist(db)

    elif content_type == "mitre":
        # CVE-MITRE 데이터베이스 형식으로 연결 
        base = cvemitre.Cvemitre(db)

    elif content_type == "icscert":
        # ICS-CERT 데이터베이스 형식으로 연결 
        raise NotImplementedError("ICS-CERT Framework wasn't implemented")
    
    # Use the selected database
    if not base.use_database(database_name):
        print("예상치 못한 오류로 인해 데이터베이스를 사용할 수 없습니다: {name}".format(name=database_name))

    # 테이블을 검증합니다.
    if not base.create_table(table_name):
        print("테이블 여부를 검증하고 있습니다: {name}".format(name=table_name))
    else:
       print("테이블을 생성하였습니다: {name}".format(name=table_name))

    # 작업을 진행하면서 추출되는 출력 파일들의 경로를 담습니다.
    export_filepath = []

    # 연도 별로 CVE 데이터베이스 작업을 설정해주고 수행합니다.
    if year_based_task:
        for year in list_year:
            export_filepath.append(configure_task(base, table_name, year, filename, file_path))
    
        if len(base.execption_list) != 0:
            log_filename = "err-{time}.log".format(time=datetime.now()).replace(" ", "").replace(":", ".")
            current_key = list(base.execption_list.keys())
            with open(log_filename, 'w+', encoding='utf-8') as fs:
                for ex in current_key:
                    for v in list(base.execption_list.get(ex)):
                        if isinstance(v, str) and re.compile("CVE-.").match(v):
                            value = v
                            fs.write("실패: Column에 값을 넣을 수 없습니다. -> {cve} | Reason: {r}\n".format(cve=v, r=ex))
                            break
                fs.close()
            print("\n경고: {count} elements could not be inserted into the table. See {f} for more reasons.\n".format(count=len(base.execption_list), f=log_filename))
            base.execption_list.clear()
    else:
        export_filepath.append(configure_task(base, table_name, None, filename, file_path))
    
    # 출력 파일로 만들어져야 할 것이 있습니까?
    if len(output_filetype) != 0:
        if filename is None:
            filename = table_name
        for f in output_filetype:
            export_filepath.append(base.export(filename, f, table_name))
    
    # 최종 출력 파일을 ZIP로 구축하려고 합니까?
    if zip_file:
        if filename is None:
            filename = "unspecific"
        print("ZIP output file detected!")
        if len(export_filepath) != 0:
            zip = zipfile.ZipFile(filename + ".zip", 'w')
            for path in export_filepath:
                zip.write(path, compress_type = zipfile.ZIP_DEFLATED)
                os.remove(path)
            zip.close()
            print(filename + ".zip was created and compressed successfully.")
            